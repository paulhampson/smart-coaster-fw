<!--
Copyright (C) 2025 Paul Hampson

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License version 3 as  published by the Free
Software Foundation.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <https://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html>
<head>
    <title>SmartCoaster Firmware Loader</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
        }

        #status {
            padding: 10px;
            border: 1px solid #ccc;
            margin: 10px 0;
            font-weight: bold;
        }

        #progress {
            width: 100%;
            height: 20px;
            margin: 10px 0;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type="file"] {
            margin: 10px 0;
        }

        #log {
            border: 1px solid #ccc;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            background: #f5f5f5;
            font-family: monospace;
            font-size: 12px;
        }

        .error {
            color: red;
            font-weight: bold;
        }

        .success {
            color: green;
        }

        .info {
            color: blue;
        }

        .debug {
            color: gray;
        }

        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 12px;
            color: #666;
        }

        footer a {
            color: #0066cc;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
    </style>
</head>
<body>
<h1>SmartCoaster Firmware Loader</h1>

<div>
    <button id="download-latest-btn">Load Latest Release</button>
    <label for="firmware-file">or Select Local Firmware File:</label>
    <input type="file" id="firmware-file" accept=".bin"/>
    <span id="firmware-size"></span>
</div>

<div>
    <button id="connect-btn">Connect and Upload to Device</button>
    <button id="disconnect-btn" disabled>Disconnect</button>
</div>

<div id="status">Status: Ready</div>
<div>Progress:
    <progress id="progress" max="100" value="0"></progress>
    <span id="progress-text"></span>
</div>

<h3>Log:</h3>
<div id="log"></div>

<footer>
    <p>SmartCoaster Web Interface v0.1.2 | <a href="https://github.com/paulhampson/smart-coaster-fw" target="_blank">GitHub Repository</a></p>
</footer>

<script type="module">
    import init, {init_logging, WasmFirmwareLoader} from './pkg/smartcoaster_host_core.js';

    let loader = null;
    let firmwareData = null;
    let port = null;
    let reader = null;
    let writer = null;
    let isConnected = false;
    let isUploading = false;
    let txPending = false;
    let lastChunk = 0;

    const BUFFER_SIZE = 4096;
    const READ_TIMEOUT = 5000;

    const log = (msg, level = 'info') => {
        if (level === 'info' || level === 'debug') {
            return;
        }
        const logDiv = document.getElementById('log');
        const timestamp = new Date().toLocaleTimeString('en-US', {hour12: false});
        const className = level;
        logDiv.innerHTML += `<span class="${className}">[${timestamp}] ${msg}</span><br>`;
        logDiv.scrollTop = logDiv.scrollHeight;
    };

    const setStatus = (msg) => {
        document.getElementById('status').textContent = `Status: ${msg}`;
    };

    const updateProgress = (progress) => {
        if (progress && progress.max_chunks > 0) {
            const percent = (progress.current_chunk / progress.max_chunks) * 100;
            document.getElementById('progress').value = Math.min(percent, 100);
            document.getElementById('progress-text').textContent =
                ` ${progress.current_chunk}/${progress.max_chunks} chunks`;
        }
    };

    document.getElementById('firmware-file').addEventListener('change', async (e) => {
        try {
            firmwareData = await e.target.files[0].arrayBuffer();
            const sizeKb = (firmwareData.byteLength / 1024).toFixed(2);
            document.getElementById('firmware-size').textContent = ` (${sizeKb} KB)`;
            log(`Loaded firmware: ${sizeKb} KB`, 'success');
        } catch (err) {
            log(`Error loading firmware: ${err.message}`, 'error');
        }
    });

    document.getElementById('download-latest-btn').addEventListener('click', async () => {
        try {
            setStatus('Downloading latest release...');
            log('Fetching latest release from GitHub...', 'info');

            const response = await fetch('https://github.com/paulhampson/smart-coaster-fw/releases/latest/download/smartcoaster-application.bin');

            if (!response.ok) {
                throw new Error(`GitHub download failed: ${response.statusText}`);
            }

            firmwareData = await response.arrayBuffer();
            const sizeKb = (firmwareData.byteLength / 1024).toFixed(2);
            document.getElementById('firmware-size').textContent = ` (${sizeKb} KB)`;

            log(`Downloaded latest firmware from github: ${sizeKb} KB`, 'success');
            setStatus('Ready');

            // Update the file input to show a file was loaded
            document.getElementById('firmware-file').value = '';
        } catch (err) {
            log(`Error downloading firmware: ${err.message}`, 'error');
            setStatus('Download Failed');
        }
    });

    document.getElementById('connect-btn').addEventListener('click', async () => {
        try {
            // Check if firmware is loaded
            if (!firmwareData) {
                log('Error: Load firmware file first', 'error');
                return;
            }

            if (!navigator.serial) {
                throw new Error('Web Serial API not supported. Please use Chrome/Edge/Opera.');
            }

            port = await navigator.serial.requestPort();
            await port.open({baudRate: 115200});
            isConnected = true;

            log('Device connected', 'success');
            setStatus('Connected');

            document.getElementById('connect-btn').disabled = true;
            document.getElementById('disconnect-btn').disabled = false;
            document.getElementById('firmware-file').disabled = true;

            reader = port.readable.getReader();
            writer = port.writable.getWriter();

            // Give device time to initialize
            await new Promise(resolve => setTimeout(resolve, 100));

            log('Starting firmware upload immediately...', 'info');

            // Start upload automatically
            await startUpload();
        } catch (err) {
            log(`Connection error: ${err.message}`, 'error');
            setStatus('Connection Failed');
            if (port) {
                try {
                    await port.close();
                } catch (e) {
                    // Ignore
                }
            }
        }
    });

    document.getElementById('disconnect-btn').addEventListener('click', async () => {
        await disconnectDevice();
    });

    async function processSessionHandler(incomingBytes) {
        try {
            log(`Processing ${incomingBytes.length} bytes from device`, 'debug');
            loader.handle_incoming_bytes(incomingBytes);

            // Check progress
            const progress = loader.get_progress();
            if (progress) {
                log(`Progress: ${progress.current_chunk}/${progress.max_chunks}`, 'debug');
                if (progress.max_chunks > 0 && progress.current_chunk > lastChunk) {
                    updateProgress(progress);
                    lastChunk = progress.current_chunk;
                }
            }

            // Check if session ended
            const sessionEnded = loader.is_session_ended();
            if (sessionEnded) {
                log('Session ended', 'success');
            }
        } catch (err) {
            // Log more details about the error
            log(`Session handler error: ${err.message}`, 'error');
            console.error('Session handler error details:', err);
            throw err;
        }
    }

    async function runUploadLoop() {
        const startTime = Date.now();
        const timeout = 120000; // 120 second timeout
        let loopCount = 0;

        while (isUploading && isConnected) {
            loopCount++;

            // Check timeout
            if (Date.now() - startTime > timeout) {
                throw new Error('Upload timeout - no response from device');
            }

            // Send any pending data
            if (!txPending) {
                try {
                    const bytesToSend = loader.get_bytes_to_send();
                    if (bytesToSend && bytesToSend.length > 0) {
                        log(`[Loop ${loopCount}] Sending ${bytesToSend.length} bytes`, 'debug');
                        await writer.write(new Uint8Array(bytesToSend));
                        log(`Sent ${bytesToSend.length} bytes`, 'info');
                        txPending = true;
                    }
                } catch (err) {
                    log(`Error in get_bytes_to_send: ${err.message}`, 'error');
                    console.error('get_bytes_to_send error:', err);
                    throw new Error(`Failed to get/send data: ${err.message}`);
                }
            }

            // Try to read data with timeout
            try {
                const readPromise = reader.read();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Read timeout')), READ_TIMEOUT)
                );

                const {value, done} = await Promise.race([readPromise, timeoutPromise]);

                if (done) {
                    throw new Error('Device disconnected unexpectedly');
                }

                if (value && value.length > 0) {
                    log(`[Loop ${loopCount}] Received ${value.length} bytes`, 'debug');
                    txPending = false;

                    // Process incoming bytes
                    await processSessionHandler(value);

                    // Check if session has ended
                    if (loader.is_session_ended()) {
                        log('Session ended - exiting upload loop', 'debug');
                        isUploading = false;
                        break;
                    }
                }
            } catch (err) {
                if (err.message === 'Read timeout') {
                    // Expected for non-blocking read, continue
                    log(`[Loop ${loopCount}] Read timeout (expected), continuing...`, 'debug');
                    await new Promise(resolve => setTimeout(resolve, 10));
                } else {
                    log(`Error during read: ${err.message}`, 'error');
                    console.error('Read error details:', err);
                    throw err;
                }
            }
        }

        log('Upload loop completed', 'info');
    }

    async function disconnectDevice() {
        try {
            isConnected = false;
            isUploading = false;

            if (reader) {
                await reader.cancel();
                reader = null;
            }
            if (writer) {
                await writer.close();
                writer = null;
            }
            if (port) {
                await port.close();
                port = null;
            }

            log('Device disconnected', 'success');
            setStatus('Disconnected');

            document.getElementById('connect-btn').disabled = false;
            document.getElementById('disconnect-btn').disabled = true;
            document.getElementById('firmware-file').disabled = false;
        } catch (err) {
            log(`Disconnection error: ${err.message}`, 'error');
        }
    }

    async function startUpload() {
        if (!firmwareData) {
            log('Error: Load firmware first', 'error');
            return;
        }

        if (!isConnected || !reader || !writer) {
            log('Error: Connect to device first', 'error');
            return;
        }

        try {
            // Initialize Rust logging
            await init();
            init_logging();  // Add this line to enable Rust logs
            log('Rust logging initialized', 'debug');

            isUploading = true;
            txPending = false;
            lastChunk = 0;

            document.getElementById('progress').value = 0;
            document.getElementById('progress-text').textContent = '';

            log('Initializing firmware loader session...', 'info');
            setStatus('Initializing...');

            // Create loader instance
            loader = new WasmFirmwareLoader(new Uint8Array(firmwareData));
            loader.init_session();

            log(`Firmware size: ${(firmwareData.byteLength / 1024).toFixed(2)} KB`, 'info');

            // Initialize session by sending zero-length buffer (triggers hello message)
            await processSessionHandler(new Uint8Array(0));

            log('Transferring firmware to device...', 'success');
            log('Waiting for device response...', 'info');
            setStatus('Uploading...');

            // Main communication loop
            await runUploadLoop();

            if (loader.is_session_ended()) {
                log('Firmware transfer completed', 'success');
                setStatus('Complete');
                log('Please wait for device to load firmware and boot', 'info');

                // Auto-disconnect after successful transfer
                log('Disconnecting from device...', 'info');
                await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay for device to finalize
                await disconnectDevice();
            }
        } catch (err) {
            console.error('Full error:', err);
            log(`Upload failed: ${err.message}`, 'error');
            setStatus('Upload Failed');
        } finally {
            isUploading = false;
        }
    }

    // Initialize on page load
    log('SmartCoaster Firmware Loader Ready', 'success');
</script>
</body>
</html>